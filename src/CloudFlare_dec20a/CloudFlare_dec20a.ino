#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <ESP8266WiFiMulti.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecureBearSSL.h>
#include <WiFiClient.h>
#include <ESP8266WebServer.h>
#include <ESP8266NetBIOS.h>
#include <HttpClient.h>
#include <Arduino_JSON.h>
#include <WakeOnLan.h>
#include <WiFiUdp.h>
#include <WakeOnLan.h>

/* 
  Sketch generated by the Arduino IoT Cloud Thing "CloudFlare"
  https://create.arduino.cc/cloud/things/4272918d-63f0-4dc9-81bd-18663c915e21 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String cloudip;
  String wanip;
  int refreshTime;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"




void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();
  

  WiFi.mode(WIFI_STA);
  WiFi.begin(wifissid, wifipassword);
  Serial.println("");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(wifissid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  // localip=WiFi.localIP();
  wwwserver.on("/", handleRoot);
  wwwserver.on("/wol", handleWol);
  wwwserver.on("/ip", []() {
    wwwserver.send(200, "text/plain", wanip);
  });
  NBNS.begin("ESP");
  wwwserver.begin();
  Serial.println("HTTP server started");
  WOL.setRepeat(3, 100);
  WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());
  digitalWrite(wifiPin, HIGH);

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
  wwwserver.handleClient();
  refreshWanIP();
  
}

/*
  Since Ssid is READ_WRITE variable, onSsidChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSsidChange()  {
  // Add your code here to act upon Ssid change
}

/*
  Since Passwd is READ_WRITE variable, onPasswdChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPasswdChange()  {
  // Add your code here to act upon Passwd change

}







static void handleRoot(void) {
  Serial.println("root request start:");
  String content;
  content = F("<!DOCTYPE HTML>\n<html>WangShiFu ESP8266 Proccessor~ HelloWorld~");
  content += F("<p>Now IP:<a>");
  content += wanip;
  content += F("</a></p>");
  content += F("</html>");
  wwwserver.send(200, F("text/html"), content);
  Serial.println("root request end~");
}

static void handleWol(void) {
  Serial.println("wol request start:");
  // WOL.sendMagicPacket(MACAddress);
  WOL.sendMagicPacket(MACAddress);
  Serial.println("wol request end:00:23:24:7B:A7:68"); 
  String content;
  content = F("<!DOCTYPE HTML>\n<html>wol proccess done~");
  content += F("<p>Now IP:<a>");
  content += wanip;
  content += F("</a></p>");
  content += F("</html>");
  wwwserver.send(200, F("text/html"), content);
  Serial.println("wol request end~");
}


void checkCFZONEID() {
  Serial.printf("Check CFZONEID ...\n");

  String url =  "https://api.cloudflare.com/client/v4/zones?name=" + CFZONE_NAME;
  std::unique_ptr<BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);
  client->setInsecure();
  HTTPClient https;
  Serial.println("[HTTPS] checkCFZONEID begin...");
  url.replace("\n", "");
  url.replace("\t", "");
  url.replace("\r", "");
  url.replace("\"", "");
  url.replace(" ", "");
  // Serial.println(url);
  if (https.begin(*client, url)) {  // HTTPS
    // Serial.println("[HTTPS] checkCFZONEID GET https://api.cloudflare.com/client/v4/zones?name=" + CFZONE_NAME + "...");
    https.addHeader("Content-Type", "application/json");
    https.addHeader("X-Auth-Email", CFUSER);
    https.addHeader("X-Auth-Key", CFKEY);
    int httpCode = https.GET();
    if (httpCode > 0) {
      Serial.printf("[HTTPS] checkCFZONEID GET... code: %d\n", httpCode);
      if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
        String jsonDataString;
        String payload = https.getString();
        // Serial.println(payload);
        jsonDataString = payload;
        JSONVar jsonData = JSON.parse(jsonDataString);
        if (JSON.typeof(jsonData) == "undefined") {
          Serial.println("Parsing input failed!");
          return;
        }
        JSONVar keys = jsonData.keys();
        int dataResult = -1;
        bool dataSuccess = false;
        String dataValue = "";
        for (int i = 0; i < keys.length(); i++) {
          JSONVar value = jsonData[keys[i]];
          JSONVar dataKey = keys[i];

          JSONVar resultStr = "result";
          if (dataKey == resultStr) {
            dataResult = i;
          }
          JSONVar successKeyStr = "success";
          JSONVar successValueStr = true;
          if (dataKey == successKeyStr) {
            dataSuccess = (value == successValueStr);
          }
          // Serial.print(keys[i]);
          // Serial.print(" = ");
          // Serial.println(value);

        }
        if (dataSuccess) {
          // Serial.println(" data success -=-=-=-=-=-=-=-= ");
          JSONVar idData = jsonData["result"][0]["id"];
          CFZONE_ID = JSON.stringify(idData);
          CFZONE_ID.replace("\n", "");
          CFZONE_ID.replace("\t", "");
          CFZONE_ID.replace("\r", "");
          CFZONE_ID.replace("\"", "");
          CFZONE_ID.replace(" ", "");
          // Serial.println(idData);
          Serial.println("CFZONE_ID:" + CFZONE_ID);
          // Serial.println(" data success -=-=-=-=-=-=-=-= ");
        }
      } else {
        String payload = https.getString();
        Serial.println("======err=====msg==========");
        Serial.println(payload);
        Serial.println("======err=====msg==========");
      }
    } else {
      Serial.printf("[HTTPS] checkCFZONEID GET... failed, error: %s\n", https.errorToString(httpCode).c_str());
    }
    https.end();
  } else {
    Serial.printf("[HTTPS] Unable to connect\n");
  }

  //CFZONE_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$CFZONE_NAME" -H "X-Auth-Email: $CFUSER" -H "X-Auth-Key: $CFKEY" -H "Content-Type: application/json" | grep -Po '(?<="id":")[^"]*' | head -1 )
}

void checkCFRECORDID() {
  Serial.printf("Check CFRECORDID ...\n");

  std::unique_ptr<BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);
  client->setInsecure();
  HTTPClient https;
  String url =   "https://api.cloudflare.com/client/v4/zones/" + CFZONE_ID + "/dns_records?name=" + CFRECORD_NAME ;
  url.replace("\n", "");
  url.replace("\t", "");
  url.replace("\r", "");
  url.replace("\"", "");
  url.replace(" ", "");
  // Serial.println(url);
  Serial.println("[HTTPS] CFRECORDID begin...");
  if (https.begin(*client, url)) {  // HTTPS
    https.addHeader("Content-Type", "application/json");
    https.addHeader("X-Auth-Email", CFUSER);
    https.addHeader("X-Auth-Key", CFKEY);
    // Serial.println("[HTTPS] CFRECORDID GET["+url+"]...");
    int httpCode = https.GET();
    if (httpCode > 0) {
      // Serial.printf("[HTTPS] CFRECORDID GET... code: %d\n", httpCode);
      if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
        String payload = https.getString();
        // Serial.println(" data success -=-=-=-=-=-=-=-= ");
        // Serial.println(payload);
        // Serial.println(" data success -=-=-=-=-=-=-=-= ");
        String jsonDataString;
        jsonDataString = payload;
        JSONVar jsonData = JSON.parse(jsonDataString);
        if (JSON.typeof(jsonData) == "undefined") {
          Serial.println("Parsing input failed!");
          return;
        }
        JSONVar keys = jsonData.keys();
        int dataResult = -1;
        bool dataSuccess = false;
        String dataValue = "";
        for (int i = 0; i < keys.length(); i++) {
          JSONVar value = jsonData[keys[i]];
          JSONVar dataKey = keys[i];

          JSONVar resultStr = "result";
          if (dataKey == resultStr) {
            dataResult = i;
          }
          JSONVar successKeyStr = "success";
          JSONVar successValueStr = true;
          if (dataKey == successKeyStr) {
            dataSuccess = (value == successValueStr);
          }
          // Serial.print(keys[i]);
          // Serial.print(" = ");
          // Serial.println(value);

        }
        if (dataSuccess) {
          // Serial.println(" data success -=-=-=-=-=-=-=-= ");
          JSONVar idData = jsonData["result"][0]["id"];
          CFRECORD_ID = JSON.stringify(idData);
          CFRECORD_ID.replace("\n", "");
          CFRECORD_ID.replace("\t", "");
          CFRECORD_ID.replace("\r", "");
          CFRECORD_ID.replace("\"", "");
          CFRECORD_ID.replace(" ", "");
          // Serial.println(idData);
          Serial.println("CFRECORD_ID:" + CFRECORD_ID);
          // Serial.println(" data success -=-=-=-=-=-=-=-= ");
          // String result=JSON.stringify(jsonData);
          // String id=JSON.stringify(jsonData["result"][0]["id"]);
          // String zone_id=JSON.stringify(jsonData["result"][0]["zone_id"]);
          // String zone_name=JSON.stringify(jsonData["result"][0]["zone_name"]);
          // String name=JSON.stringify(jsonData["result"][0]["name"]);
          // String type=JSON.stringify(jsonData["result"][0]["type"]);
          String content = JSON.stringify(jsonData["result"][0]["content"]);
          // String ttl=JSON.stringify(jsonData["result"][0]["ttl"]);
          // String modified_on=JSON.stringify(jsonData["result"][0]["modified_on"]);
          cloudip = content;
          cloudip.replace("\n", "");
          cloudip.replace("\t", "");
          cloudip.replace("\r", "");
          cloudip.replace("\"", "");
          cloudip.replace(" ", "");

        }


      } else {
        String payload = https.getString();
        Serial.println("======err=====msg==========");
        Serial.println(payload);
        Serial.println("======err=====msg==========");
      }
    } else {
      Serial.printf("[HTTPS] CFRECORDID GET... failed, error: %s\n", https.errorToString(httpCode).c_str());
    }
    https.end();
  } else {
    Serial.printf("[HTTPS] Unable to connect\n");
  }
  //CFRECORD_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$CFZONE_ID/dns_records?name=$CFRECORD_NAME" -H "X-Auth-Email: $CFUSER" -H "X-Auth-Key: $CFKEY" -H "Content-Type: application/json"  | grep -Po '(?<="id":")[^"]*' | head -1 )
}

void updateDNStoWanIP() {
  if (CFZONE_ID == "" or CFRECORD_ID == ""  ) {
    Serial.println("err CFZONE_ID CFRECORD_ID   " );
    return;
  }
  Serial.printf("Updating DNS to %s\n", wanip.c_str());
  std::unique_ptr<BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);
  client->setInsecure();
  HTTPClient https;
  String url =   "https://api.cloudflare.com/client/v4/zones/" + CFZONE_ID + "/dns_records/" + CFRECORD_ID ;
  url.replace("\n", "");
  url.replace("\t", "");
  url.replace("\r", "");
  url.replace("\"", "");
  url.replace(" ", "");
  // Serial.println(url);
  Serial.print("[HTTPS] CFRECORDID begin...\n");
  if (https.begin(*client, url)) {  // HTTPS
    https.addHeader("Content-Type", "application/json");
    https.addHeader("X-Auth-Email", CFUSER);
    https.addHeader("X-Auth-Key", CFKEY);
    // Serial.println("[HTTPS] CFRECORDID GET["+url+"]...\n");
    int httpCode = https.PUT("{\"id\":\"" + CFZONE_ID + "\",\"type\":\"" + CFRECORD_TYPE + "\",\"name\":\"" + CFRECORD_NAME + "\",\"content\":\"" + wanip + "\", \"ttl\":" + CFTTL + "}");
    if (httpCode > 0) {
      // Serial.printf("[HTTPS] CFRECORDID GET... code: %d\n", httpCode);
      if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
        String payload = https.getString();

        // Serial.println(" data success -=-=-=-=-=-=-=-= ");
        // Serial.println(payload);
        // Serial.println(" data success -=-=-=-=-=-=-=-= ");
        String jsonDataString;
        jsonDataString = payload;
        JSONVar jsonData = JSON.parse(jsonDataString);
        if (JSON.typeof(jsonData) == "undefined") {
          Serial.println("Parsing input failed!");
          return;
        }
        JSONVar keys = jsonData.keys();
        // int dataResult=-1;
        bool dataSuccess = false;
        // String dataValue="";
        for (int i = 0; i < keys.length(); i++) {
          JSONVar value = jsonData[keys[i]];
          JSONVar dataKey = keys[i];
          // JSONVar resultStr="result";
          // if (dataKey==resultStr){
          //   dataResult=i;
          // }
          JSONVar successKeyStr = "success";
          JSONVar successValueStr = true;
          if (dataKey == successKeyStr) {
            dataSuccess = (value == successValueStr);
          }
          // Serial.print(keys[i]);
          // Serial.print(" = ");
          // Serial.println(value);
        }
        if (dataSuccess) {
          Serial.println(" CloudFlare DNS UPDATE SUCCESS !");
          Serial.println(" CloudFlare DNS UPDATE SUCCESS !");
          // Serial.println(" data success -=-=-=-=-=-=-=-= ");
          // String result=JSON.stringify(jsonData);
          // String id=JSON.stringify(jsonData["result"][0]["id"]);
          // String zone_id=JSON.stringify(jsonData["result"][0]["zone_id"]);
          // String zone_name=JSON.stringify(jsonData["result"][0]["zone_name"]);
          // String name=JSON.stringify(jsonData["result"][0]["name"]);
          // String type=JSON.stringify(jsonData["result"][0]["type"]);
          // String content=JSON.stringify(jsonData["result"][0]["content"]);
          // String ttl=JSON.stringify(jsonData["result"][0]["ttl"]);
          // String modified_on=JSON.stringify(jsonData["result"][0]["modified_on"]);
          // Serial.println(" data success -=-=-=-=-=-=-=-= ");

        }


      } else {
        String payload = https.getString();
        Serial.println("======err=====msg==========");
        Serial.println(payload);
        Serial.println("======err=====msg==========");
      }
    } else {
      Serial.printf("[HTTPS] CFRECORDID GET... failed, error: %s\n", https.errorToString(httpCode).c_str());
    }
    https.end();
  } else {
    Serial.printf("[HTTPS] Unable to connect\n");
  }
  // RESPONSE=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$CFZONE_ID/dns_records/$CFRECORD_ID" \
  -H "X-Auth-Email: $CFUSER" \
  -H "X-Auth-Key: $CFKEY" \
  -H "Content-Type: application/json" \
  --data "{\"id\":\"$CFZONE_ID\",\"type\":\"$CFRECORD_TYPE\",\"name\":\"$CFRECORD_NAME\",\"content\":\"$WAN_IP\", \"ttl\":$CFTTL}")

}

void setCloudflareDNS() {
  if (wanip == "0.0.0.0") {
    refreshWanIP();
  }
  if (CFZONE_ID == "" or cloudip == "0.0.0.0") {
    checkCFZONEID();
  }
  if (CFRECORD_ID == "" or cloudip == "0.0.0.0") {
    checkCFRECORDID();
  }
  if (wanip == cloudip and wanip != "0.0.0.0") {
    digitalWrite(wifiPin, LOW);
    delay(300);
    digitalWrite(wifiPin, HIGH);
    delay(300);
    digitalWrite(wifiPin, LOW);
    delay(300);
    digitalWrite(wifiPin, HIGH);
    delay(300);
    digitalWrite(wifiPin, LOW);
    delay(300);
    digitalWrite(wifiPin, HIGH);
  } else {
    updateDNStoWanIP();
  }
}

void refreshWanIP() {
  // wait for WiFi connection

  if ((WiFiMulti.run() == WL_CONNECTED)  ) {
    digitalWrite(netPin, LOW);
    if (((millis() - lastrefreshtime) > refreshTime*1000) or lastrefreshtime == 0    ) {

      lastrefreshtime = millis();
      WiFiClient client;
      HTTPClient http;
      if (http.begin(client, "http://ipv4.icanhazip.com")) {
        // Serial.println("[HTTP]GET["+IPCheckAddress+"]...");
        int httpCode = http.GET();
        if (httpCode > 0) {
          // Serial.printf("[HTTP] GET... code:%d\n",httpCode );
          if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {
            String payload = http.getString();
            String lastwanip = payload;
            lastwanip.replace("\n", "");
            lastwanip.replace("\t", "");
            lastwanip.replace("\r", "");
            lastwanip.replace(" ", "");
            // Serial.println(lastwanip);
            if (wanip == lastwanip and wanip == cloudip) {
              Serial.println("cache:[" + wanip + "] now:[" + lastwanip + "] cloud:[" + cloudip + "] ignore...");

              digitalWrite(wifiPin, LOW);
              delay(300);
              digitalWrite(wifiPin, HIGH);
              delay(300);
              digitalWrite(wifiPin, LOW);
              delay(300);
              digitalWrite(wifiPin, HIGH);
              delay(300);
              digitalWrite(wifiPin, LOW);
              delay(300);
              digitalWrite(wifiPin, HIGH);
            } else {
              Serial.println("cache:[" + wanip + "] now:[" + lastwanip + "] cloud:[" + cloudip + "]  waiting update...");
              wanip = lastwanip;
              wanip.replace("\n", "");
              wanip.replace("\t", "");
              wanip.replace("\r", "");
              wanip.replace(" ", "");
              setCloudflareDNS();
            }
          }
        } else {
          Serial.printf("[HTTP] GET... failed, error: %s\n", http.errorToString(httpCode).c_str());
        }
        http.end();
      } else {
        Serial.printf("[HTTP} Unable to connect\n");
      }
    }

  }else{
 
  }
}

/*
  Since Wanip is READ_WRITE variable, onWanipChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onWanipChange()  {
  // Add your code here to act upon Wanip change
}




/*
  Since RefreshTime is READ_WRITE variable, onRefreshTimeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRefreshTimeChange()  {
  // Add your code here to act upon RefreshTime change
}




/*
  Since NetLed is READ_WRITE variable, onNetLedChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onNetLedChange()  {
  // Add your code here to act upon NetLed change
}




/*
  Since Mac is READ_WRITE variable, onMacChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMacChange()  {
  // Add your code here to act upon Mac change
}